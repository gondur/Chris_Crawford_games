PROGRAM NeanderEditor;USES	Globals, Initialization, BotP;{$IFC NeanderLives}{*****************************************************************}PROCEDURE SpinWheel (Delay: Integer);	VAR		DelayTime: LongInt;	BEGIN		DelayTime := TickCount;		REPEAT		UNTIL (TickCount >= DelayTime + Delay) OR Button;	END;{*****************************************************************}PROCEDURE WriteTheCard (i, y: Integer);	BEGIN		TextFont(1);		TextSize(9);		MoveTo(516, y);		DrawString(CardName[i]);	END;{*****************************************************************}PROCEDURE InvertListedCardRect;	VAR		y: Integer;		TempRect: Rect;	BEGIN		y := 14 * (ListedCard - GetCtlValue(CardScroll) + 1) + 2;		IF (y > 15) & (y < 340) THEN			BEGIN				SetRect(TempRect, 515, y, 623, y + 14);				InvertRect(TempRect);			END;	END;{*****************************************************************}PROCEDURE JumpList (ScrollDist: Integer);	VAR		i, j, x, z: Integer;		StartVal: Integer;		TempRect: Rect;		TempRgn: RgnHandle;	BEGIN		StartVal := GetCtlValue(CardScroll);		IF ScrollDist <> 0 THEN			BEGIN				TempRgn := NewRgn;				SetRect(TempRect, 515, 16, 623, 321);				FOR i := 1 TO 7 DO					BEGIN						ScrollRect(TempRect, 0, 2 * ScrollDist, TempRgn);						IF ScrollDist > 0 THEN							ClearRect(515, 340, 623, 321)						ELSE							ClearRect(515, 14, 623, 15);					END;				DisposeRgn(TempRgn);				i := 0;				IF ScrollDist > 0 THEN					BEGIN						WriteTheCard(StartVal, 27);						IF StartVal = ListedCard THEN							InvertListedCardRect;					END				ELSE					BEGIN						WriteTheCard(StartVal + 21, 321);						IF (StartVal + 21) = ListedCard THEN							InvertListedCardRect;					END;			END		ELSE			BEGIN {ScrollDist=0}				ClearRect(515, 14, 623, 322);				FOR i := StartVal TO StartVal + 21 DO					IF i <= MaxNoCards THEN						BEGIN							WriteTheCard(i, 14 * (i - StartVal + 1) + 13);							IF i = ListedCard THEN								InvertListedCardRect;						END;			END;		SpinWheel(3);	END;{************************************************************************}PROCEDURE ScrollList (theControl: ControlHandle; thisPart: Integer);	VAR		delta: Integer;		OldValue: Integer;		x: Integer;	BEGIN		CASE thisPart OF			inUpButton: 				delta := -1;			inDownButton: 				delta := 1;			inPageUp: 				delta := -12;			inPageDown: 				delta := 12;			OTHERWISE				delta := 0;		END;		IF thisPart <> 0 THEN			BEGIN				oldValue := GetCtlValue(CardScroll);				SetCtlValue(CardScroll, oldValue + delta);				IF GetCtlValue(CardScroll) <> oldValue THEN					BEGIN						IF Abs(delta) = 1 THEN							x := -delta						ELSE							x := 0;						JumpList(x);					END;			END;	END;{*****************************************************************}PROCEDURE WhichAbleItems;	VAR		i, j: Integer;		Pretzel: Boolean;	BEGIN		IF ThisCard = 0 THEN			BEGIN				DisableItem(MenuArr[2], 2);				DisableItem(MenuArr[2], 3);				DisableItem(MenuArr[2], 4);				DisableItem(MenuArr[3], 0);				DisableItem(MenuArr[4], 0);			END		ELSE			BEGIN				EnableItem(MenuArr[3], 0);				EnableItem(MenuArr[4], 0);				EnableItem(MenuArr[2], 1);				EnableItem(MenuArr[2], 2);				EnableItem(MenuArr[2], 3);				EnableItem(MenuArr[2], 4);				IF NumTextBoxes < MaxTextBoxes THEN					EnableItem(MenuArr[3], 1)				ELSE					DisableItem(MenuArr[3], 1);				EnableItem(MenuArr[3], 2);				EnableItem(MenuArr[3], 3);				FOR i := 5 TO 15 DO					EnableItem(MenuArr[3], i);				IF NumTriangles < MaxTriangles THEN					EnableItem(MenuArr[4], 1)				ELSE					DisableItem(MenuArr[4], 1);			END;		IF ThisTextBox = 0 THEN			BEGIN				DisableItem(MenuArr[3], 2);				DisableItem(MenuArr[3], 3);				FOR i := 5 TO 15 DO					DisableItem(MenuArr[3], i);			END		ELSE			BEGIN				EnableItem(MenuArr[3], 2);				EnableItem(MenuArr[3], 3);				FOR i := 5 TO 15 DO					EnableItem(MenuArr[3], i);			END;		IF ThisTriangle = 0 THEN			BEGIN				DisableItem(MenuArr[4], 2);				DisableItem(MenuArr[4], 3);				DisableItem(MenuArr[4], 5);			END		ELSE			BEGIN				EnableItem(MenuArr[4], 2);				EnableItem(MenuArr[4], 3);				EnableItem(MenuArr[4], 5);			END;		IF CardName[ListedCard] = 'Untitled' THEN			BEGIN				DisableItem(MenuArr[2], 1);			END		ELSE			BEGIN				EnableItem(MenuArr[2], 1);			END;	END;{*****************************************************************}PROCEDURE DrawFrame;	VAR		i, x, y: Integer;		MyPixPat: PixPatHandle;		TempRect: Rect;	BEGIN		JumpList(0);		MoveTo(0, BitMapHeight);		LineTo(640, BitMapHeight);		ClearRect(513, 0, 639, BitMapHeight);		MoveTo(514, 0);		LineTo(514, BitMapHeight);		DrawControls(MainWind);		TextFont(0);		TextSize(12);		MoveTo(515, 14);		DrawString('    Name');		JumpList(0);		MyPixPat := NewPixPat;		FOR i := 0 TO 255 DO			BEGIN				Index2Color(LongInt(i), ThisColor);				MakeRGBPat(MyPixPat, ThisColor);				x := (i MOD 36) * 16;				y := (i DIV 36) * 16;				SetRect(TempRect, x, y + BitMapHeight + 4, x + 16, y + BitMapHeight + 20);				FillCRect(TempRect, MyPixPat);			END;		DisposPixPat(MyPixPat);		DrawControls(MainWind);	END;{*****************************************************************}PROCEDURE InitEditor;	VAR		i, j, x, y: Integer;		TempRect: Rect;		TempStr: Str255;		BigStdRect: Rect;		oldDevice: GDHandle;		theMaxDevice: GDHandle;	BEGIN		QuitFlag := FALSE;		SetRect(BigStdRect, 0, 20, 640, 474);		theMaxDevice := GetMaxDevice(BigStdRect);		IF YesColor THEN			BEGIN				MainWind := NewCWindow(NIL, BigStdRect, 'NeanderCardEditor', TRUE, DocumentProc, WindowPtr(-1), FALSE, 1);				YesColor := (theMaxDevice^^.gdPMap^^.pixelSize > 1);				oldDevice := GetGDevice;				SetGDevice(theMaxDevice);			END		ELSE			MainWind := NewWindow(NIL, StdRect, 'NeanderCardEditor', TRUE, DocumentProc, WindowPtr(-1), FALSE, 1);		SetPort(MainWind);		FillRect(MainWind^.portrect, white);		SetRect(TempRect, 623, 0, 639, BitMapHeight);		CardScroll := NewControl(MainWind, TempRect, '', TRUE, 1, 1, MaxNoCards - 22, ScrollBarProc, 0);		FOR i := 1 TO 4 DO			BEGIN				MenuArr[i] := GetMenu(i);				InsertMenu(MenuArr[i], 0);			END;		DrawMenuBar;		ThisCard := 1;		Turn := 1;		LoadCard;		JumpLocation := EarthProc;		ListedCard := ThisCard;		ThisTriangle := 0;		ThisTextBox := 0;		WhichAbleItems;		ThisColor.red := -1;		ThisColor.green := -1678;		ThisColor.blue := 21354;	END;{*****************************************************************}PROCEDURE SetText (VAR PassedStr: Str255);	VAR		j: Integer;		ItemHit: Integer;		ClickDlog: DialogPtr;		ItemType: Integer;		ItemHandle: Handle;		TempStr: Str255;		TempRect: Rect;		theControl: ControlHandle;		Number: LongInt;	BEGIN		ClickDlog := GetNewDialog(337, NIL, Pointer(-1));		GetDItem(ClickDlog, 3, ItemType, ItemHandle, TempRect);		SetIText(ItemHandle, PassedStr);		IF PassedStr = 'Boop-Boop-De-Boop' THEN			SelIText(ClickDlog, 3, 0, 255);		InitCursor;		REPEAT			ModalDialog(NIL, ItemHit);			GetDItem(ClickDlog, ItemHit, ItemType, ItemHandle, TempRect);		UNTIL ItemHit = 1;		GetDItem(ClickDlog, 3, ItemType, ItemHandle, TempRect);		GetIText(ItemHandle, PassedStr);		DisposDialog(ClickDlog);		DrawCard;	END;{*****************************************************************}PROCEDURE SetAColor (VAR PassedColor: RGBColor);	VAR		j: Integer;		ItemHit: Integer;		ColorDlog: DialogPtr;		ItemType: Integer;		ItemHandle: Handle;		TempStr: Str255;		TempRect: Rect;		theControl: ControlHandle;		Number: LongInt;	BEGIN		ColorDlog := GetNewDialog(338, NIL, Pointer(-1));		GetDItem(ColorDlog, 3, ItemType, ItemHandle, TempRect);		Number := LongInt(PassedColor.red);		NumToString(Number, TempStr);		SetIText(ItemHandle, TempStr);		GetDItem(ColorDlog, 4, ItemType, ItemHandle, TempRect);		Number := LongInt(PassedColor.green);		NumToString(Number, TempStr);		SetIText(ItemHandle, TempStr);		GetDItem(ColorDlog, 5, ItemType, ItemHandle, TempRect);		Number := LongInt(PassedColor.blue);		NumToString(Number, TempStr);		SetIText(ItemHandle, TempStr);		InitCursor;		REPEAT			ModalDialog(NIL, ItemHit);			GetDItem(ColorDlog, ItemHit, ItemType, ItemHandle, TempRect);		UNTIL ItemHit = 1;		GetDItem(ColorDlog, 3, ItemType, ItemHandle, TempRect);		GetIText(ItemHandle, TempStr);		StringToNum(TempStr, Number);		PassedColor.red := Integer(Number);		ThisColor.red := Integer(Number);		GetDItem(ColorDlog, 4, ItemType, ItemHandle, TempRect);		GetIText(ItemHandle, TempStr);		StringToNum(TempStr, Number);		PassedColor.green := Integer(Number);		ThisColor.green := Integer(Number);		GetDItem(ColorDlog, 5, ItemType, ItemHandle, TempRect);		GetIText(ItemHandle, TempStr);		StringToNum(TempStr, Number);		PassedColor.blue := Integer(Number);		ThisColor.blue := Integer(Number);		DisposDialog(ColorDlog);		DrawCard;	END;{*****************************************************************}PROCEDURE SaveCard;	VAR		i: Integer;		FolderName: Str255;	BEGIN {save card}		IF CardName[ThisCard] <= 'J' THEN			FolderName := ':Cards A-J:'		ELSE			FolderName := ':Cards K-W:';		Error := FSDelete(Concat(FolderName, CardName[ThisCard]), 0);		Error := Create(Concat(FolderName, CardName[ThisCard]), 0, 'BoPG', 'BoPC');		Error := FSOpen(Concat(FolderName, CardName[ThisCard]), 0, RefNum);		Count := 10;		Error := FSWrite(RefNum, Count, @PackedSize);		IF CardType[ThisCard] = 0 THEN			BEGIN				Error := FSWrite(RefNum, PackedSize, PackedMapPtr);				i := 1;				WHILE i <= NumTriangles DO					BEGIN						Count := SizeOf(CTriRec);						Error := FSWrite(RefNum, Count, @CTriangle[i]);						i := i + 1;					END;			END;		i := 1;		WHILE i <= NumTextBoxes DO			BEGIN				Count := 14;				Error := FSWrite(RefNum, Count, @TextBox[i]);				Count := Length(TextBoxText[i]) + 1;				Error := FSWrite(RefNum, Count, @TextBoxText[i]);				i := i + 1;			END;		Count := LongInt(EquationLength);		Error := FSWrite(RefNum, Count, @EquationText);		Error := FSClose(RefNum);	END;{*****************************************************************}PROCEDURE OpenCard;	VAR		i, x: Integer;		FileNameStr: Str255;	BEGIN		IF ThisCard > 0 THEN			SaveCard;		IF CardName[ListedCard] <= 'J' THEN			FileNameStr := Concat(':Cards A-J:', CardName[ListedCard])		ELSE			FileNameStr := Concat(':Cards K-W:', CardName[ListedCard]);		Error := FSOpen(FileNameStr, 0, RefNum);		IF Error = 0 THEN			BEGIN				Error := FSClose(RefNum);				ThisCard := ListedCard;				LoadCard;				ThisTextBox := 0;				ThisTriangle := 0;				DrawCard;				WhichAbleItems;			END		ELSE			BEGIN				IF Error = FNFErr THEN					BEGIN {couldn't find the card, let's look for the MacPaint file}						IF CardName[ListedCard] <= 'J' THEN							Error := FSOpen(Concat(':Paint A-J:', CardName[ListedCard]), 0, RefNum)						ELSE							Error := FSOpen(Concat(':Paint K-W:', CardName[ListedCard]), 0, RefNum);						IF Error = 0 THEN							BEGIN {load MacPaint file}								Count := headersize;								Error := FSRead(RefNum, Count, PackedMapPtr);								PackedSize := MaxScreenSize;								Error := FSRead(RefNum, PackedSize, PackedMapPtr);								Error := FSClose(RefNum);								ThisCard := ListedCard;								CauseCount[ThisCard] := 0;								EffectCount[ThisCard] := 0;								NumTextBoxes := 0;								NumTriangles := 0;								EquationLength := 1;								EquationText[1] := '@';								Error := Create(FileNameStr, 0, 'VOPE', 'VOPC');								SaveCard;								ThisTextBox := 0;								ThisTriangle := 0;								WhichAbleItems;								DrawCard;							END						ELSE							BEGIN								IF (Error = FNFErr) & (CardType[ListedCard] > 0) THEN									BEGIN										ThisCard := ListedCard;										CauseCount[ThisCard] := 0;										EffectCount[ThisCard] := 0;										NumTextBoxes := 0;										NumTriangles := 0;										EquationLength := 1;										EquationText[1] := '@';										Error := Create(FileNameStr, 0, 'VOPE', 'VOPC');										SaveCard;										ThisTextBox := 0;										ThisTriangle := 0;										WhichAbleItems;										DrawCard;									END								ELSE									x := StopAlert(335, NIL);							END;					END;			END; {outer else-clause}	END;{*****************************************************************}PROCEDURE DoCommand (mResult: LongInt); {general menu command handler}	CONST		AppleMenu = 1;		FileMenu = 2;		TextBoxMenu = 3;		TriangleMenu = 4;		EquationMenu = 5;	VAR		theMenu: Integer;		theItem: Integer;		i, j, k, x, y: Integer;		x1, y1: Integer;		srcSize: Integer;		DlgOrigin: Point;		TypeList: SFTypeList;		TheReply: SFReply;		SaveFlag: Boolean;		TempRect: Rect;		PlusCurs: CursHandle;		VertexCount: Integer;		MousePt: Point;		SavedCard: Integer;	BEGIN		theMenu := HiWord(mResult);		theItem := LoWord(mResult);		CASE theMenu OF			AppleMenu: 				BEGIN					IF theItem = 1 THEN						BEGIN							SetRect(TempRect, 100, 100, 300, 200);							FillRect(TempRect, white);							FrameRect(TempRect);							MoveTo(110, 150);							DrawString('There is nothing to say');							MoveTo(110, 170);							DrawString('about this editor');							REPEAT							UNTIL Button;							DrawCard;						END				END;			FileMenu: 				CASE theItem OF					1: 						OpenCard;					2: 						SaveCard;					3: 						BEGIN {reload bitmap}							SetPt(DlgOrigin, 100, 85);							TypeList[0] := 'PNTG';							SFGetFile(DlgOrigin, '', NIL, 1, TypeList, NIL, TheReply);							IF TheReply.good THEN								BEGIN									Error := FSOpen(TheReply.fName, TheReply.vRefNum, RefNum);									Count := headersize;									Error := FSRead(RefNum, Count, PackedMapPtr);									PackedSize := MaxScreenSize;									Error := FSRead(RefNum, PackedSize, PackedMapPtr);									Error := FSClose(RefNum);								END;							DrawCard;						END;					4: 						BEGIN							Error := FSOpen(Concat(':Equation Ä:', CardName[ThisCard]), 0, RefNum);							IF Error = 0 THEN								BEGIN									Count := 2048;									Error := FSRead(RefNum, Count, @EquationText);									EquationLength := Count;								END							ELSE								BEGIN									EquationLength := 0;									SysBeep(10);								END;							Error := FSClose(RefNum);							ProcessEquationText;						END;					5: 						BEGIN							SavedCard := ThisCard;							FOR i := 1 TO MaxNoCards DO								BEGIN									ThisCard := i;									LoadCard;									IF Error = 0 THEN										BEGIN											Error := FSOpen(Concat(':Equation Ä:', CardName[ThisCard]), 0, RefNum);											IF Error = 0 THEN												BEGIN													Count := 2048;													Error := FSRead(RefNum, Count, @EquationText);													EquationLength := Count;												END											ELSE												EquationLength := 0;											Error := FSClose(RefNum);											SaveCard;										END;								END; {i-loop}							ThisCard := SavedCard;							LoadCard;						END;					6: 						BEGIN							RunStack;							LoadCard;							DrawCard;						END;					7: 						BEGIN							QuitFlag := TRUE;						END;				END; {FileMenu CASE statement}			TextBoxMenu: 				BEGIN					CASE theItem OF						1: 							BEGIN								NumTextBoxes := NumTextBoxes + 1;								SetRect(TextBox[NumTextBoxes].TRect, 50, 100, 350, 200);								TextBox[NumTextBoxes].TFont := 2;								TextBox[NumTextBoxes].TSize := 12;								TextBox[NumTextBoxes].TFace := 0;								TextBoxText[NumTextBoxes] := 'Boop-Boop-De-Boop';								SetText(TextBoxText[NumTextBoxes]);								ThisTextBox := NumTextBoxes;								EnableItem(MenuArr[3], 2);								EnableItem(MenuArr[3], 3);								IF NumTextBoxes = MaxTextBoxes THEN									DisableItem(MenuArr[3], 1);							END;						2: 							BEGIN								i := ThisTextBox;								WHILE (i < NumTextBoxes) & (i > 0) DO									BEGIN										TextBox[i] := TextBox[i + 1];										TextBoxText[i] := TextBoxText[i + 1];										i := i + 1;									END;								ThisTextBox := 0;								NumTextBoxes := NumTextBoxes - 1;								WhichAbleItems;								DrawCard;							END;						3: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								SetText(TextBoxText[ThisTextBox]);						4: 							BEGIN								ThisTriangle := 0;								ThisTextBox := ThisTextBox + 1;								IF ThisTextBox > NumTextBoxes THEN									ThisTextBox := 0;								WhichAbleItems;							END;						5: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TFont := 0;						6: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TFont := 1;						7: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TFont := 2;						8: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TSize := 9;						9: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TSize := 10;						10: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TSize := 12;						11: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TSize := 14;						12: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TSize := 18;						13: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TFace := 0;						14: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TFace := 1;						15: 							IF (ThisTextBox > 0) & (ThisTextBox <= NumTextBoxes) THEN								TextBox[ThisTextBox].TFace := 2;					END; {TextBoxMenu CASE statement}					DrawCard;				END; {TextBoxMenu instance}			TriangleMenu: 				CASE theItem OF					1: 						BEGIN							NumTriangles := NumTriangles + 1;							IF NumTriangles = MaxTriangles THEN								DisableItem(MenuArr[4], 1);							EnableItem(MenuArr[4], 2);							EnableItem(MenuArr[4], 3);							EnableItem(MenuArr[4], 5);							PlusCurs := GetCursor(2);							SetCursor(PlusCurs^^);							REPEAT							UNTIL Button;							GetMouse(MousePt);							x := MousePt.h;							y := MousePt.v;							IF x < 0 THEN								x := 0;							IF x > BitMapWidth THEN								x := BitMapWidth;							IF y < 0 THEN								y := 0;							IF y > BitMapHeight THEN								y := BitMapHeight;							CTriangle[NumTriangles].Vertices[1].h := x;							CTriangle[NumTriangles].Vertices[1].v := y;							VertexCount := 1;							REPEAT							UNTIL NOT Button;							REPEAT							UNTIL NOT StillDown;							SpinWheel(10);							REPEAT								PenPat(gray);								PenMode(PatXOr);								x := CTriangle[NumTriangles].Vertices[VertexCount].h;								y := CTriangle[NumTriangles].Vertices[VertexCount].v;								REPEAT									GetMouse(MousePt);									x1 := MousePt.h;									y1 := MousePt.v;									IF x1 < 0 THEN										x1 := 0;									IF x1 > BitMapWidth THEN										x1 := BitMapWidth;									IF y1 < 0 THEN										y1 := 0;									IF y1 > BitMapHeight THEN										y1 := BitMapHeight;									MoveTo(x, y);									LineTo(x1, y1);									MoveTo(x, y);									LineTo(x1, y1);								UNTIL Button;								REPEAT								UNTIL NOT Button;								PenNormal;								MoveTo(x, y);								LineTo(x1, y1);								VertexCount := VertexCount + 1;								CTriangle[NumTriangles].Vertices[VertexCount].h := x1;								CTriangle[NumTriangles].Vertices[VertexCount].v := y1;							UNTIL VertexCount = 3;							InitCursor;							FlushEvents(everyEvent, 0);							CTriangle[NumTriangles].color := ThisColor;							ThisTriangle := NumTriangles;							DrawCard;						END;					2: 						BEGIN							i := ThisTriangle;							WHILE i < NumTriangles DO								BEGIN									CTriangle[i] := CTriangle[i + 1];									i := i + 1;								END;							NumTriangles := NumTriangles - 1;							IF ThisTriangle > NumTriangles THEN								ThisTriangle := NumTriangles;							WhichAbleItems;							DrawCard;						END;					3: 						BEGIN							IF ThisTriangle > 0 THEN								SetAColor(CTriangle[ThisTriangle].color);						END;					4: 						BEGIN							ThisTextBox := 0;							ThisTriangle := ThisTriangle + 1;							IF ThisTriangle > NumTriangles THEN								BEGIN									DisableItem(MenuArr[4], 2);									DisableItem(MenuArr[4], 3);									DisableItem(MenuArr[4], 5);									ThisTriangle := 0;								END							ELSE								BEGIN									EnableItem(MenuArr[4], 2);									EnableItem(MenuArr[4], 3);									EnableItem(MenuArr[4], 5);								END;							DrawCard;						END;					5: 						BEGIN							ThisColor := CTriangle[ThisTriangle].color;						END;				END; {TriangleMenu instance}			OTHERWISE				BEGIN {spoof the damn compiler}				END;		END;		IF NOT QuitFlag THEN			HiLiteMenu(0);	END;{*****************************************************************}PROCEDURE TakeInput;	VAR		i, j, k, m, x, y, Mx, My: Integer;		l, r, t, b: Integer;		dx, dy: Integer;		ch: Char;		whichWindow: WindowPtr;		JunkPart: Integer;		TempRect: Rect;		MousePt: Point;		TimeDelay: LongInt;		DClickTime: LongInt;		SubFlag: Boolean;		TextBoxClicked: Boolean;		ClickBoxWidth: Integer;		theMaxDevice: GDHandle;	BEGIN		DClickTime := TickCount;		REPEAT			SystemTask;			IF GetNextEvent(everyEvent, myEvent) THEN				BEGIN					CASE myEvent.what OF						UpdateEvt: 							BEGIN								GetPort(SavePort);								whichWindow := WindowPtr(MyEvent.message);								SetPort(whichWindow);								theMaxDevice := GetMaxDevice(MainWind^.portrect);								YesColor := (theMaxDevice^^.gdPMap^^.pixelSize > 1);								BeginUpdate(whichWindow);								DrawCard;								DrawFrame;								EndUpdate(MainWind);								SetPort(SavePort);							END;						KeyDown: 							BEGIN								x := BitAnd(myEvent.message, CharCodeMask);								ch := Chr(x);								IF BitAnd(myEvent.modifiers, CmdKey) <> 0 THEN									DoCommand(MenuKey(ch));							END;						mouseDown: 							BEGIN								thePart := FindWindow(myEvent.where, whichWindow);								CASE thePart OF									InMenuBar: 										DoCommand(MenuSelect(myEvent.where));									InContent: 										BEGIN											GlobalToLocal(MyEvent.where);											TextBoxClicked := FALSE;											IF (MyEvent.where.h < BitMapWidth) & (MyEvent.where.v < BitMapHeight) THEN												BEGIN													IF ThisTextBox > 0 THEN														BEGIN															i := ThisTextBox;															IF PtInRect(MyEvent.where, TextBox[i].TRect) THEN																BEGIN {user clicked in a textbox}																	TextBoxClicked := TRUE;																	l := TextBox[i].TRect.left;																	t := TextBox[i].TRect.top;																	r := TextBox[i].TRect.right;																	b := TextBox[i].TRect.bottom;																	SetRect(TempRect, l, t, l + HandleSize, t + HandleSize);																	IF PtInRect(MyEvent.where, TempRect) THEN																		BEGIN {click in topleft handle}																			PenPat(gray);																			PenMode(PatXOr);																			REPEAT																				FrameRect(TextBox[i].TRect);																				GetMouse(MousePt);																				MX := MousePt.h;																				MY := MousePt.v;																				IF PtInRect(MousePt, MainWind^.portrect) & (MX < (r - 60)) & (MY < (b - 20)) THEN																					SetRect(TextBox[i].TRect, MX, MY, r, b);																				FrameRect(TextBox[i].TRect);																			UNTIL NOT StillDown;																			PenNormal;																			DrawCard;																		END																	ELSE																		BEGIN																			SetRect(TempRect, r - HandleSize, b - HandleSize, r, b);																			IF PtInRect(MyEvent.where, TempRect) THEN																				BEGIN {click in bottomright handle}																					PenPat(gray);																					PenMode(PatXOr);																					REPEAT																						FrameRect(TextBox[i].TRect);																						GetMouse(MousePt);																						MX := MousePt.h;																						MY := MousePt.v;																						IF PtInRect(MousePt, MainWind^.portrect) & (MX > (l + 60)) & (MY > (t + 20)) THEN																							SetRect(TextBox[i].TRect, l, t, MX, MY);																						FrameRect(TextBox[i].TRect);																					UNTIL NOT StillDown;																					PenNormal;																					DrawCard;																				END;																		END; {inner ELSE-clause}																END; {of "user clicked in a textbox" IF}														END; {ThisTextBox>0 IF}													IF (ThisCard > 0) & NOT TextBoxClicked THEN														BEGIN															SubFlag := FALSE;															i := 1;															WHILE i <= NumTriangles DO																BEGIN																	j := 1;																	WHILE (j <= 3) & NOT SubFlag DO																		BEGIN																			x := CTriangle[i].Vertices[j].h;																			y := CTriangle[i].Vertices[j].v;																			SetRect(TempRect, x - HandleRad, y - HandleRad, x + HandleRad, y + HandleRad);																			IF PtInRect(MyEvent.where, TempRect) THEN																				BEGIN {click on vertex}																					PenPat(gray);																					PenMode(PatXOr);																					REPEAT																						MoveTo(CTriangle[i].Vertices[3].h, CTriangle[i].Vertices[3].v);																						FOR m := 1 TO 3 DO																							LineTo(CTriangle[i].Vertices[m].h, CTriangle[i].Vertices[m].v);																						GetMouse(MousePt);																						IF PtInRect(MousePt, BitMapRect) THEN																							CTriangle[i].Vertices[j] := MousePt;																						MoveTo(CTriangle[i].Vertices[3].h, CTriangle[i].Vertices[3].v);																						FOR m := 1 TO 3 DO																							LineTo(CTriangle[i].Vertices[m].h, CTriangle[i].Vertices[m].v);																					UNTIL NOT StillDown;																					PenNormal;																					DrawCard;																					SubFlag := TRUE;																				END;																			j := j + 1;																		END;																	i := i + 1;																END;														END; {ThisCard>0 IF}												END; {IF-test for MyEvent.where falling inside BitMap}											IF (MyEvent.where.h > 512) & (MyEvent.where.h < 624) & (MyEvent.where.v < BitMapHeight) THEN												BEGIN {Amanda clicked in the CardName}													IF TickCount < DClickTime + 30 THEN														BEGIN															OpenCard;														END													ELSE														BEGIN															DClickTime := TickCount;															InvertListedCardRect;															ListedCard := GetCtlValue(CardScroll) + ((MyEvent.where.v - 17) DIV 14);															InvertListedCardRect;															WhichAbleItems;														END;												END;											IF (MyEvent.where.v > BitMapHeight + 3) & (MyEvent.where.h < 576) THEN												BEGIN {click in the color palette}													i := (((MyEvent.where.v - BitMapHeight - 4) DIV 16) * 36) + MyEvent.where.h DIV 16;													IF i < 256 THEN														BEGIN															x := (i MOD 36) * 16;															y := (i DIV 36) * 16;															SetRect(TempRect, x, y + BitMapHeight + 4, x + 16, y + BitMapHeight + 20);															InvertRect(TempRect);															REPEAT															UNTIL NOT StillDown;															InvertRect(TempRect);															Index2Color(LongInt(i), ThisColor);															IF ThisTriangle > 0 THEN																BEGIN																	CTriangle[ThisTriangle].color := ThisColor;																	DrawCard;																END;														END; {i<256 IF}												END;											JunkPart := FindControl(MyEvent.where, whichWindow, whichControl);											IF whichControl = CardScroll THEN												BEGIN													IF JunkPart = InThumb THEN														BEGIN															thePart := TrackControl(whichControl, MyEvent.where, NIL);															JumpList(0);														END													ELSE														thePart := TrackControl(CardScroll, MyEvent.where, @ScrollList);												END;										END;									OTHERWISE								END; {thePart CASE}							END; {mousedown instance}						OTHERWISE					END;				END; {GetNextEvent IF}		UNTIL QuitFlag;	END;{$ENDC}{****************************************************************}BEGIN	{ main program }	InitBasicStuff;{$IFC NeanderLives}	InitEditor;	InitCursor;	TakeInput;{$ELSEC}	InitGame;	InitCursor;	RunStack;{$ENDC}END.